Nume: Potoceanu Ana-Maria
Grupa: 311CAb
Titlu + numar tema: Load Balancer, Tema 2

    Pentru realizarea unui Load Balancer, am implementat prima data functionalitatile serverului. Pentru fiecare server,
vom retine hashtable-ul si id-ul corespunzator. Am utilizat hashtable-ul care a fost pus la dispozitie in cadrul
laboratorului. Prima data, am creat functia de initializare a unui server. Pentru hashtable-ul dintr-un server,
ne folosim de functia ht_create. Stocarea datelor intr-un hashtable o facem cu ajutorul functiei ht_put. 
Pentru aflarea valorii asociate unei chei am folosit ht_get, iar pentru stergerea unei chei am utilizat ht_remove_entry.
In final, am eliberat memoria pentru intregul server.

    Pentru implementarea unui Load Balancer am folosit un vector care va contine toate etichetele, sortate dupa hash-ul 
etichetelor. Am numit acest vector hashring. Vectorul trebuie mentinut sortat pentru a putea face cautare binara, fiind
considerata o metoda mai eficienta. Am creat si un vector de pointeri catre serverele principale, care nu va contine si
celelalte doua replici. Am retinut, de asemenea, numarul de elemente din hashring si numarul de servere.

    Functia loader_store stocheaza un obiect pe unul dintre serverele disponibile. Initial parcurgem hashring-ul, 
verificam unde trebuie adaugat obiectul in functie de hash-ul lui, aflam pozitia serverului in care trebuie adaugat 
si in final il punem in serverul dorit, folosind server_store. Daca obiectul nu a fost inca adaugat il vom pune 
in serverul care corespunde primei etichete din hashring.

    In functia loader_retrieve aflam pe ce server se afla cheia pe care o avem si ii extragem valorea. Aici am abordat
din nou doua cazuri, la fel ca in functia loader_store.

    In cadrul functiei loader_add_server, prima data am realocat vectorul hashring si cel cu servere, deoarece
odata cu adaugare unui nou server, se vor adauga in hashring cele trei etichete corespunzatoare. Pentru adugarea unui element
in hashring am folosit functia put_hashring. Daca nu avem niciun element in vector, atunci vom adauga pe prima pozitie.
Trebuie sa adugam etichetele in functie de hash, pentru a mentine vectorul sortat. Initial, am tratat cazul cand trebuie 
sa punem pe prima pozitie, mai exact daca hash-ul etichetei pe care vrem sa o adaugam este mai mic decat hash-ul primei
etichete din hashring. Mai departe, avem cazul cand vom adauga in interiorul hashring-ului. Verificam unde trebuie sa 
adugam eticheta si vom muta toate elementele cu o pozitie la dreapta, pentru a face loc etichetei. Daca eticheta nu a fost
inca adugata, inseamna ca va fi pusa pe ultima pozitie. De fiecare data cand adaugam un server trebuie sa facem redistribuirea
elementelor. In functia map, folosim cautarea binara pentru a gasi in hashring pozitia etichetei. Vom retine de asemenea si 
urmatoarea pozitie pentru a putea calcula id-ul corespunzator. Trebuie sa facem verificarea sa nu avem o replica, deoarece 
redistribuirea se face catre un server nou. Parcurgem hashtable-ul si mutam elementele din server vechi in cel nou.

    Functia loader_remove_server sterge un server. Atunci cand stergem un server, va trebui sa eliminam toate replicile
sale din hashring. Acest lucru l-am facut cu ajutorul functiei delete_hashring. Cautam pozitia pe care se afla eticheta data,
folosind cautare binara si mutam elementele cu o pozitie la stanga. Dupa ce se sterge un server din sistem trebuie sa
redistribuim elementele din el, astfel am implementat functia map_delete. Pentru inceput, aflam pozitia din vectorul de servere
(pe care se afla serverul cu id-ul dat). Parcurgem intregul hashtable si stocam elemetele ramase pe serverele disponibile.
In final, eliberam memoria pentru serverul care urmeaza a fi sters si mutam elementele din vectorul de servere cu o pozitie la
stanga. 

    In final, eliberam memoria pentru load_balancer. Prima data, eliberam vectorul cu etichete, apoi parcurgem vectorul de servere
si dealocam memoria pentru fiecare server in parte.


